## Effective Java 2/E
1. __객체의 생성과 삭제__
  * 01. 생성자 대신 정적 팩터리 메소드를 사용할 수 없는지 생각해보라
  * 02. 생성자 인자가 많을 때는 Builder패턴 적용을 고려하자
  * 03.private 생성자나 enum자료형은 싱글턴 패턴을 따르도록 설계하라
  * 04. 객체 생성을 막을 때는 private생성자를 사용하라
  * 05. 불필요한 객체는 만들지 말라
  * 06. 유효기간이 지난 객체 참조는 폐기하라
  * 07. 종료자 사용을 피하라
  
2. __모든 객체의 공통 메서드__
  * 08. equals를 재정의할 때는 일반 규약을 따르라
  * 09. equals를 재정의할 때는 반드시 hashCode도 재정의하라
  * 10. toString은 항상 재정의 하라
  * 11. clone을 재정의할 때는 신중하라
  * 12. Comparable구현을 고려하라
  
3. __클래스와 인터페이스__
  * 13. 클래스와 멤버의 접근 권한은 최소화하라
  * 14. public 클래스 안에는 public 필드를 두지 말고 접근자 메서드를 사용하라
  * 15. 변경 가능성을 최소화하라
  * 16. 계승하는 대신 구성하라
  * 17. 계승을 위한 설계와 문서를 갖추거나, 그럴 수 없다면 계승을 금지하라
  * 18. 추상 클래스 대신 인터페이스를 사용하라
  * 19. 인터페이스는 자료형을 정의할 때만 사용하라
  * 20. 태그 달린 클래스 대신 클래스 계층을 활용하라
  * 21. 전략을 표현하고 싶을 때는 함수 객체를 사용하라
  * 22. 멤버 클래스는 가능하면 static으로 선언하라

4. __제네릭__
  * 23. 새 코드에는 무인자 제네릭 자료형을 사용하지 마라
  * 24. 무점검 경고(unchecked warning)를 제거하라
  * 25. 배열 대신 리스트를 써라
  * 26. 가능하면 제네릭 자료형으로 만들 것
  * 27. 가능하면 제네릭 메서드로 만들 것
  * 28. 한정적 와일드카드를 써서 API 유연성을 높여라
  * 29. 형 안전 다형성 컨테이너를 쓰면 어떨지 따져보라

5. __열거형(enum)과 에노테이션__
  * 30. int 상수 대신 enum을 사용하라
  * 31. ordinal 대신 객체 필드를 사용하라 
  * 32. 비트 필드(bit field) 대신 EnumSet을 사용하라
  * 33. ordinal을 배열 첨자로 사용하는 대신 EnumMap을 이용하라
  * 34. 확장 가능한 enum을 만들어야 한다면 인터페이스를 이용하라 
  * 35. 작명 패턴 대신 어노테이션을 사용하라 
  * 36. Override 어노테이션은 일관되게 사용하라
  * 37. 자료형을 정의할 때 표식 인터페이스를 사용하라

6. __메서드__
  * 38. 인자의 유효성을 검사하라
  * 39. 필요하다면 방어적 복사본을 만들라
  * 40. 메서드 시그너처는 신중하게 설계하라
  * 41. 오버로딩할 때는 주의하라
  * 42. varargs는 신중히 사용하라
  * 43. null 대신 빈 배열이나 컬렉션을 반환하라 
  * 44. 모든 API 요소에 문서화 주석을 달라 

7. __일반적인 프로그래밍 원칙들__
  * 45. 지역 변수의 유효범위를 최소화하라
  * 46. for 문보다는 for-each 문을 사용하라 
  * 47. 어떤 라이브러리가 있는지 파악하고, 적절히 활용하라 
  * 48. 정확한 답이 필요하다면 float와 double은 피하라 
  * 49. 객체화된 기본 자료형 대신 기본 자료형을 이용하라
  * 50. 다른 자료형이 적절하다면 문자열 사용은 피하라 
  * 51. 문자열 연결 시 성능에 주의하라
  * 52. 객체를 참조할 때는 그 인터페이스를 사용하라
  * 53. 리플렉션 대신 인터페이스를 이용하라
  * 54. 네이티브 메서드는 신중하게 사용하라
  * 55. 신중하게 최적화하라
  * 56. 일반적으로 통용되는 작명 관습을 따르라

8. __에외__
  * 57. 예외는 예외적 상황에만 사용하라
  * 58. 복구 가능 상태에는 점검지정 예외를 사용하고, 프로그래밍 오류에는 실행시점 예외를 이용하라
  * 59. 불필요한 점검지정 예외 사용은 피하라
  * 60. 표준 예외를 사용하라
  * 61. 추상화 수준에 맞는 예외를 던져라
  * 62. 메서드에서 던져지는 모든 예외에 대해 문서를 남겨라
  * 63. 어떤 오류인지를 드러내는 정보를 상세한 메시지에 담으라
  * 64. 실패 원자성 달성을 위해 노력하라
  * 65. 예외를 무시하지 마라

9. __병행성__
  * 66. 변경 가능 공유 데이터에 대한 접근은 동기화하라
  * 67. 과도한 동기화는 피하라
  * 68. 스레드보다는 실행자와 태스크를 이용하라
  * 69. wait나 notify 대신 병행성 유틸리티를 이용하라
  * 70. 스레드 안전성에 대해 문서로 남겨라
  * 71. 초기화 지연은 신중하게 하라
  * 72. 스레드 스케줄러에 의존하지 마라
  * 73. 스레드 그룹은 피하라

10. __직열화__
  * 74. Serializable 인터페이스를 구현할 때는 신중하라
  * 75. 사용자 지정 직렬화 형식을 사용하면 좋을지 따져 보라
  * 76. readObject 메서드는 방어적으로 구현하라
  * 77. 개체 통제가 필요하다면 readResolve 대신 enum 자료형을 이용하라
  * 78. 직렬화된 객체 대신 직렬화 프락시를 고려해 보라
