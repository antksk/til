모델과 다른 모델과의 관계가 지닌 한계를 인식하고 전달하며, 선택하는 기법에 대해 정리함.
현 프로젝트 분야를 매핑하는 것에서 부터 출발하여, Context Map(컨텍스트 맵)이 프로젝트의
컨텍스트와 각 컨텍스트 간의 관계의 전체적인 개관을 제공해 주는 반면 Bounded Context는
각 모델의 적용가능성의 범위를 정의한다.
이 처럼 일단 컨텍스트가 제한되면(Bounded Context), Continuous Integration(지속적인 통합)
프로세스를 토데로 모델의 단일화를 유지 할수 있다.


### Bounded Context
> 세포가 생존할 수 있는 것은 세포막에서 세포의 내부에 존재할 수 있는 것과 외부에 존재해야 하는 것을
> 정의하고 어떤 물질이 세포막을 통과할 수 있는지 결정하기 때문이다.
>
> 도메인 주도 개발 p.361

> 모델이 적용되는 컨텍스트를 명시적으로 정의하라. 컨텍스트의 경계를 팀 조직,
> 애플리케이션의 특정 부분에서의 사용법, 코드 기반이나 데이터 베이스 스키마와 같은 물리적인 형태의 관점에서
> 명시적으로 설정하라.
> 이 경계 내에서는 __모델을 엄격하게 일관된 상태로 유지하고 경계 바깥의 이슈 때문에 초점이 흐려지거나 혼란스러워져서는 안된다.__
>
> 도메인 주도 개발 p.362


#### Bounded Context는 Module이 아니다.
> 간혹 두 용어를 혼동하는 경구가 있는데, Bounded Context와 Module은 서로 동기가 다른 패턴이다.
> 사실 어떤 두 객체 집합이 각기 다른 모델을 구성한다고 여겨지면
> 두 객체 집합은 거의 항상 서로 다른 개별 Module내에 위치한다.(경계가 명확히 분리되어 있음)
> 이렇게 해서 서로 네임스페이스(서로 다른 Context를 위한 필수 요소)와 일종의 경계를 제공할 수 있다.
>
> 그러나, Module은 단일 모델 내에 포함된 요소를 구성하는 데도 사용되며, 꼭 개별 Context에 의도를 전하는 것이 아니다.
> 실제로는 Bounded Context내에 Module이 만들어낸 개별 네임스페이스가 포함되면 우발적으로 발생하는
> 모델의 단편화를 파악하기가 더운 어려워진다.

##### 내가 생각하는 Bounded Context vs Module
- Bounded Context : 개념이 다른 네임스페이스(패키지)로 명확히 분리 해 낼수 있으며, 분리된 영역 끼리 서로 의사 전달을 할수 있는
  공통의 인터페이스 구간이 존재한다. Bounded Context내에 Module이 포함될수 있다.
  예를 들어, 상품이라는 Bounded Context 개념을 설계 할수 있으며, 이 안에는 다양한 종류의 상품들을 모데링한 도메인 모델이 존재 할수 있다.
  이 상품 Bounded Context는 결제나 가격과 같은 Bounded Context와 통신을 하기 위한 인터페이스를 제공한다.

- Module : 아주 작은 단위의 경계 체계에서도 사용되는 개념(클래스안에 존재하는 메서드에서도 사용될수 있을 만큼 작은 개념)으로
  다른 영역의 개념에 __어떤 의도 를 전달 하려는 목적을 갖지 않는다.__

주의할 점은, 프로젝트를 있는 그대로 봐야지 이상적인 프로젝트를 생각해서는 안된다.

#### Bounded Context 안의 균열 인식
- 코드로 작성된 인터페이스가 서로 맞지 않는 경우
- 뚜렷이 구분되는 모델 요소를 결합할 경우
  - 중복된 개념 : 실제로 같은 개념을 나타내는 두개의 모델 요소이 존재하는 경우
  - 허위 동족 언어(false cognates) : 같은 용어(혹은 구현 객체)를 사용하는 두 사람이 서로 같은 것을 이야기하고 있다고 생각하지만
    실제로는 그렇지 않은 경우
- 해결 방안
  - 지속적인 통합(Continuous Integration) : 내부적으로 균열이 발생할 때 이를 빠르게 포착하고
    정정할 수 있을 정도로 컨텍스트 내의 모든 작업을 빈번하게 병합해서 일관성을 유지하는 것을 의미한다.
    이 개념이 제일 중요한 데, 그 이유는 통합하는 과정에서 균열에 대한 인식을 빠르게 확인 할 수 있고,
    중복된 개념을 빠르게 발견할 수 있기 때문이다.
  - 익스트림 프로그래밍(XP, Extreme Programming)

### Context Map
- Context Map은 프로젝트 관리와 소프트웨어 설계 영역 사이에 걸쳐 있는 개념
- 개별적인 Bounded Context로는 전체를 조망할 수 없다. 그래서 다른 모델의 컨텍스트는 여전히 모호하고 유동적이다.
- Bounded Context간에 코드를 재사용하는 것은 위험하므로 피해야 한다. 기능과 데이터는 번역 과정을 거쳐 통합해야 한다.
- 서로 다른 컨텍스트 간의 관계를 정의하고 프로젝트상의 모든 모델 컨텍스트를 아우르는 전체적인 뷰를 만들면 혼란을 줄일수 있다.
- Bounded Context간의 관계 패턴(참고 p.381 ~ p.403)
  - 공유 커널(Shared Kernel)
  - 고객/공급자 개발팀(Customer/Supplier) (현재 가장 많이 적용되어 있는 패턴)
  - 오류 장지 계층(Anticorruption Layer) (wrapper, translator, facade, service)
  - 각자의 길(Separate Ways)
  - 공개 호스트 서비스(Open Host Service)


> Context Map이 항상 현재 상태 그대로의 상황을 표현한다는 사실을 염두에 둔다면 컨텍스트에서 발견하게 되는
> 관계가 처음에는 패턴과 딱맞아 떨어지지 않을 수도 있다.
> 유사성이 눈에 띈다면 패턴 이름을 사용하고 싶어 질수도 있지만 이를 강요해서는 안된다.
> 단지 __발견한 관계를 서술하기만 한다.__ 나중에 좀더 표준화된 관계로 이를 변경할 수 있다.
>
> 그렇다면 균열(서로 완전히 뒤얽혀 있지만 비일관성을 내포하는 모델)을 발견했다면 어떻게 해야 할까?
> __Context Map에 모른다고 적어 놓고 거기서 서술을 중단한다.__ 그러고 나서 정확한 전체적인 뷰를
> 가지고 혼란스러운 지점을 설명한다. 작은 균열은 수선할 수 있으며, 균열 때문에 무너지지 않게 적절한 프로세스를
> 활용해 이를 지탱할 수 있다.
>
> 도메인 주도 개발 p.372


### Shared Kernel(공유 커널)
> 밀접하게 연관된 애플리케이션을 대상으로 작업 중인 팀간의 협력이 조율되지 않는 다면 잠시 동안은 작업을
> 진행할 수 있겠지만 각 팀이 만들어낸 결과물을 함께 조합하기는 쉽지 않을 것이다.
> 결국 처음부터 Continuous Integration을 적용 했을때 보다 더 많은 시간을 번역 계층을 개발하고
> 구조를 개선하는 데 허비하게 될 것이며, 동시에 공통 Ubiquitous Language를 구죽하는 작업이
> 중복되고 Ubiquitous Language로 얻을 수 있는 이점을 잃어 버리게 된다.
> 그러므로,
> 두 팀 간에 공유하기로 한 도메인 모델의 부분집합을 명시하라. 물론 여기에는 모델의 부분집합뿐
> 아니라 모델 요소와 연관된 코드나 데이터베이스 설계의 부분집합까지도 포함된다.
> 명시적으로 공유하는 부분들은 특별한 상태를 가지며, 다른 팀과의 협의 없이는 변경할 수 없다.
> 기능 시스템을 자주 통합하라. 하지만 개별 티멩서 수행하는 Continuous Integration빈도는 보다
> 더 적은 빈도로 통합하라. 통합할 때는 양 팀에서 작성한 테스트를 모두 실행하라.
>
> __Shared Kernel은 설계 내의 다른 부분만큼 자유롭게 변경할수 없다.__ (다른 팀과 연계되어 있기 때문에)
> 의사결정은 다른 팀과의 협의를 거쳐서 이뤄져야 하기 때문이다.
>
> 도메인 주도 개발 p.382
