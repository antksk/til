모델과 다른 모델과의 관계가 지닌 한계를 인식하고 전달하며, 선택하는 기법에 대해 정리함.
현 프로젝트 분야를 매핑하는 것에서 부터 출발하여, Context Map(컨텍스트 맵)이 프로젝트의
컨텍스트와 각 컨텍스트 간의 관계의 전체적인 개관을 제공해 주는 반면 Bounded Context는
각 모델의 적용가능성의 범위를 정의한다.
이 처럼 일단 컨텍스트가 제한되면(Bounded Context), Continuous Integration(지속적인 통합)
프로세스를 토데로 모델의 단일화를 유지 할수 있다.


### Bounded Context
> 세포가 생존할 수 있는 것은 세포막에서 세포의 내부에 존재할 수 있는 것과 외부에 존재해야 하는 것을
> 정의하고 어떤 물질이 세포막을 통과할 수 있는지 결정하기 때문이다.
>
> 도메인 주도 개발 p.361

> 모델이 적용되는 컨텍스트를 명시적으로 정의하라. 컨텍스트의 경계를 팀 조직,
> 애플리케이션의 특정 부분에서의 사용법, 코드 기반이나 데이터 베이스 스키마와 같은 물리적인 형태의 관점에서
> 명시적으로 설정하라.
> 이 경계 내에서는 __모델을 엄격하게 일관된 상태로 유지하고 경계 바깥의 이슈 때문에 초점이 흐려지거나 혼란스러워져서는 안된다.__
>
> 도메인 주도 개발 p.362


#### Bounded Context는 Module이 아니다.
> 간혹 두 용어를 혼동하는 경구가 있는데, Bounded Context와 Module은 서로 동기가 다른 패턴이다.
> 사실 어떤 두 객체 집합이 각기 다른 모델을 구성한다고 여겨지면
> 두 객체 집합은 거의 항상 서로 다른 개별 Module내에 위치한다.(경계가 명확히 분리되어 있음)
> 이렇게 해서 서로 네임스페이스(서로 다른 Context를 위한 필수 요소)와 일종의 경계를 제공할 수 있다.
>
> 그러나, Module은 단일 모델 내에 포함된 요소를 구성하는 데도 사용되며, 꼭 개별 Context에 의도를 전하는 것이 아니다.
> 실제로는 Bounded Context내에 Module이 만들어낸 개별 네임스페이스가 포함되면 우발적으로 발생하는
> 모델의 단편화를 파악하기가 더운 어려워진다.

##### 내가 생각하는 Bounded Context vs Module
- Bounded Context : 개념이 다른 네임스페이스(패키지)로 명확히 분리 해 낼수 있으며, 분리된 영역 끼리 서로 의사 전달을 할수 있는
  공통의 인터페이스 구간이 존재한다. Bounded Context내에 Module이 포함될수 있다.
  예를 들어, 상품이라는 Bounded Context 개념을 설계 할수 있으며, 이 안에는 다양한 종류의 상품들을 모데링한 도메인 모델이 존재 할수 있다.
  이 상품 Bounded Context는 결제나 가격과 같은 Bounded Context와 통신을 하기 위한 인터페이스를 제공한다.

- Module : 아주 작은 단위의 경계 체계에서도 사용되는 개념(클래스안에 존재하는 메서드에서도 사용될수 있을 만큼 작은 개념)으로
  다른 영역의 개념에 __어떤 의도 를 전달 하려는 목적을 갖지 않는다.__

주의할 점은, 프로젝트를 있는 그대로 봐야지 이상적인 프로젝트를 생각해서는 안된다.

#### Bounded Context 안의 균열 인식
- 코드로 작성된 인터페이스가 서로 맞지 않는 경우
- 뚜렷이 구분되는 모델 요소를 결합할 경우
  - 중복된 개념 : 실제로 같은 개념을 나타내는 두개의 모델 요소이 존재하는 경우
  - 허위 동족 언어(false cognates) : 같은 용어(혹은 구현 객체)를 사용하는 두 사람이 서로 같은 것을 이야기하고 있다고 생각하지만
    실제로는 그렇지 않은 경우
- 해결 방안
  - 지속적인 통합(Continuous Integration) : 내부적으로 균열이 발생할 때 이를 빠르게 포착하고
    정정할 수 있을 정도로 컨텍스트 내의 모든 작업을 빈번하게 병합해서 일관성을 유지하는 것을 의미한다.
    이 개념이 제일 중요한 데, 그 이유는 통합하는 과정에서 균열에 대한 인식을 빠르게 확인 할 수 있고,
    중복된 개념을 빠르게 발견할 수 있기 때문이다.
  - 익스트림 프로그래밍(XP, Extreme Programming)

Bounded Context의 경계를 세우는 데는 무수히 많은 상황과 선택이 있다. 하지만 대개 문제는
아래의 요인들 사이에서 균형을 유지하는데 있다.
##### 규모가 큰 Bounded Context가 선호되는 경우
- 사용자의 작업 흐름이 단일화된 모델을 토대로 처리될 때 더 매끄럽게 진행된다.
- 개별적인 두 모델의 매핑을 더하는 것보다 일관성 있는 하나의 모델을 이해하기가 더 쉽다.
- 두 모델 간의 번역이 어려울 수 있다.(불가능한 경우도 있음)
- 공유 언어를 토대로 팀의 의사소통이 명확해진다.

##### 규모가 작은 Bounded Context가 선호되는 경우
- 개발자 간의 의사소통에 따른 과부하가 줄어든다.
- 소규모 팀과 코드 기반을 토대로 Continuous Integration이 쉬워진다.
- 대형 컨텍스트에서는 용도가 다양한 추상화 모델을 요구할 수도 있는데, 이 경우 제공하기 힘든 기술일 필요할 때가 있다.
- 각기 다른 모델은 특수한 요구사항을 해결하는 데 도움되거나 Ubiquitous Language의 특화된 방언과
  전문적인 사용자 집단의 전문용어를 포괄할 수 있다.

#### Bounded Context 변형(Bounded Context Transformation)
일반적으로 Context를 나누기는 상당히 쉽지만 각 Context를 통합하고 각 Context간의 관계를 바꾸기란 결코 쉬운 일이 아니다.
대부분 규모가 너무 커서 단 한번의 리팩터링이나 프로젝트 반복주기로는 쉽게 변경할수 없다. 이러한 이유로 변경을 위한 벙법을 일련의
관리 가능한 단계로 간략하게 정리한다.
- Context병합 : Separate Ways --> Shared Kernel
  1. 초기 상황을 평가한다. 두 Context를 단일화하기 전에 두 Context가 실제로 내부적으로도 단일화돼 있는지 확인한다.
  2. 프로세스를 수립한다. 코드를 공유하는 방법과 사용할 모듈 명명 규칙을 결정해야 한다.
     적어도 Shared Kernel의 코드는 주 간격으로 통합돼야 한다. 또한 __Shared Kernel의 코드는 테스트 슈트를 가지고 있어야 한다.__
    공유 코드를 개발하기 전에는 반드시 이러한 사항들 마련한다.
  3. 병합을 시작할 대상으로 Core Domain의 일부가 아닌 두 Context에서 중복되는 부분을 포함하는 규모가 작은 하위 도메인을 선택한다.
     이러한 첫 번째 병합의 결과로 프로세스가 수립될 것이므로 단순하고 비교적 일반적이거나 크게 중요하지 않은 것을 사용하는 편이 가장 바람직하다.
     이미 존재하는 통합 번역을 면밀히 검토한다. 현재 번역이 이뤄지고 있는 것을 선택하면 입증된 번역으로 시작한다는 이점을 있을뿐더러 변역 계층이 얇게 유지된다.
  4. 하위 도메인에 대한 공유 모델을 만들어 내기 위해 두 팀에서 데려온 2명에서 4명의 개발자로 구성된 집단을 만든다.
     모델의 도출 방식과는 관계없이 모델은 상세하게 작성해야 한다. 여기에는 동의어를 식별하고 아직 변역되지 않은 용어를 매핑하는 것과 같은 고된 작업이 포함된다. 이러한 합동팀(joint team)에서는 모델에 대한 기본적인 테스트 집합을 개략적으로 수립한다.
  5. 양쪽 팀의 개발자들은 모델을 구현하고(혹은 기존 공유 코드를 변경하고) 세부사항을 산출해내며,
     그러한 세부사항을 기능으로 만드는 작업에 착수한다. 개발자들이 모델과 관련된 문제에 봉착하면 그들은 3단계에서 팀을 재소집해서 필요한 개념을 개정하는 작업에 참여한다.
  6. 각 팀의 개발자들이 새로운 Shared Kernel에 통합하는 작업에 착수한다.
  7. 더 이상 필요 없는 번역은 제거한다.

- Context병합 : Shared Kernel --> Continuous Integration
  1. Continuous Integration에 필요한 모든 프로세스(공유 코드 소유권, 빈번한 통합등)가 각팀에 개별적으로 갖춰져 있는지 확인한다.
     모든 이들이 동일한 방식으로 업무를 수행할수 있게 두 팀을 상대로 통합 절차를 일치시킨다.
  2. 팀 간의 팀원 교류를 시작한다. 이렇게 하면 두 모델을 모두 이해하는 인력 풀(pool)이 조성되고 두 팀의 사람들이 서로 연결될 것이다.
  3. 각 모델의 디스틸레이션(distillation)과정을 각기 명확하게 만든다.
  4. 이 시점에는 핵심 도메인을 Shared Kernel에 병합하는 과정을 개시할수 있을 만큼 자신감이 생긴다. 이렇게 되기까지 수차례의 반복주기가
     걸릴 수 있으며, 간혹 새로이 공유되는 부분과 아직 공유되지 않는 부분 사이에 일시적인 번역 계층이 필요할 때도 있다.
     일단 Core Domain에 병합하게 되면 신속히 진행하는 것이 가장 바람직하다. 이것은 과부하가 매우 높은 단계로서 오류가 많이 발생하므로 대부분의 신규 개발보다 우선시해서 가급적 단계를 짧게 유지해야 한다. 하지만 다룰수 있는 범위를 넘어서는 책임을 맡아서는 안된다.
  5. Shared Kernel이 확장됨에 따라 통합이 매일 이뤄지게끔 통합의 빈도를 늘리고 결국에는 Continuous Integration에 이르게 한다.
  6. Shared Kernel이 기존의 두 Bounded Context를 전부 포괄하는 지점에 이르면 지속적으로
     통합하는(Integration Continuous) 공유 코드 기반을 갖추고 구성원을 빈번하게 교체햐는, 커다란 하나의 팀 내지는 규모가 작은 두 팀이 만들어 질것이다.
- 레거시 시스템의 단계적 폐기
  1. 단일 반복주기 내에서 신규 시스템에 추가 될수도 있는 레거지의 특정 기능을 파악한다.
  2. Anticorruption Layer에 필요할 추가사항을 파악한다.
  3. 구현
  4. 배치
  5. Anticorruption Layer에서 불필요한 부분을 파악해 이를 제거한다.
  6. 지금은 사용되지 않는 레거시 시스템 모듈을 삭제하는 것을 고려해본다.(별로 도움되는 일이 아니라고 판명 될지도 모르지만)
     아이러니하게도 레거시 시스템이 잘 설계돼 있을수록 단계적으로 폐기하기가 더욱 쉬워진다. 반면 설계가 열약한 소프트웨어를 제거하기는 더욱 어렵다.
     나머지 부분이 단계적으로 폐기되어 전체가 폐기될 때까지 사용되지 않는 부분을 무시할 수도 있다.

- Open Host Service --> Published Language
  1. 이용 가능한 업계 표준 언어가 있다면 이를 평가해보고 가급적이면 이것을 사용한다.
  2. 표준 언어나 사전에 공표된 언어가 없다면 우선 호스트 역할을 할 시스템의 Core Domain을 더 분명하게 다듬는다.
  3. Core Domain을 교환 언어의 기반으로 사용하고 가능한 한 JSON, XML과 같은 표준 교환 패러다임을 활용한다.
  4. (최소한)협업에 참여하는 모든 이에게 새로운 언어를 공표한다.
  5. 새로운 시스템 아키텍처도 관련이 있다면 이 아키텍처도 공표한다.
  6. 각 협업 시스템을 상대로 번역 계층을 구축한다.
  7. 전환

### Context Map
- Context Map은 프로젝트 관리와 소프트웨어 설계 영역 사이에 걸쳐 있는 개념
- 개별적인 Bounded Context로는 전체를 조망할 수 없다. 그래서 다른 모델의 컨텍스트는 여전히 모호하고 유동적이다.
- Bounded Context간에 코드를 재사용하는 것은 위험하므로 피해야 한다. 기능과 데이터는 번역 과정을 거쳐 통합해야 한다.
- 서로 다른 컨텍스트 간의 관계를 정의하고 프로젝트상의 모든 모델 컨텍스트를 아우르는 전체적인 뷰를 만들면 혼란을 줄일수 있다.
- Bounded Context간의 관계 패턴(참고 p.381 ~ p.403)
  - 공유 커널(Shared Kernel)
  - 고객/공급자 개발팀(Customer/Supplier)
  - 오류 장치 계층(Anticorruption Layer) (wrapper, translator, facade, service)
  - 각자의 길(Separate Ways)
  - 공개 호스트 서비스(Open Host Service)


> Context Map이 항상 현재 상태 그대로의 상황을 표현한다는 사실을 염두에 둔다면 컨텍스트에서 발견하게 되는
> 관계가 처음에는 패턴과 딱맞아 떨어지지 않을 수도 있다.
> 유사성이 눈에 띈다면 패턴 이름을 사용하고 싶어 질수도 있지만 이를 강요해서는 안된다.
> 단지 __발견한 관계를 서술하기만 한다.__ 나중에 좀더 표준화된 관계로 이를 변경할 수 있다.
>
> 그렇다면 균열(서로 완전히 뒤얽혀 있지만 비일관성을 내포하는 모델)을 발견했다면 어떻게 해야 할까?
> __Context Map에 모른다고 적어 놓고 거기서 서술을 중단한다.__ 그러고 나서 정확한 전체적인 뷰를
> 가지고 혼란스러운 지점을 설명한다. 작은 균열은 수선할 수 있으며, 균열 때문에 무너지지 않게 적절한 프로세스를
> 활용해 이를 지탱할 수 있다.
>
> 도메인 주도 개발 p.372


##### Shared Kernel(공유 커널)
> 밀접하게 연관된 애플리케이션을 대상으로 작업 중인 팀간의 협력이 조율되지 않는 다면 잠시 동안은 작업을
> 진행할 수 있겠지만 각 팀이 만들어낸 결과물을 함께 조합하기는 쉽지 않을 것이다.
> 결국 처음부터 Continuous Integration을 적용 했을때 보다 더 많은 시간을 번역 계층을 개발하고
> 구조를 개선하는 데 허비하게 될 것이며, 동시에 공통 Ubiquitous Language를 구죽하는 작업이
> 중복되고 Ubiquitous Language로 얻을 수 있는 이점을 잃어 버리게 된다.
> 그러므로,
> 두 팀 간에 공유하기로 한 도메인 모델의 부분집합을 명시하라. 물론 여기에는 모델의 부분집합뿐
> 아니라 모델 요소와 연관된 코드나 데이터베이스 설계의 부분집합까지도 포함된다.
> 명시적으로 공유하는 부분들은 특별한 상태를 가지며, 다른 팀과의 협의 없이는 변경할 수 없다.
> 기능 시스템을 자주 통합하라. 하지만 개별 팀에서 수행하는 Continuous Integration빈도는 보다
> 더 적은 빈도로 통합하라. 통합할 때는 양 팀에서 작성한 테스트를 모두 실행하라.
>
> __Shared Kernel은 설계 내의 다른 부분만큼 자유롭게 변경할수 없다.__ (다른 팀과 연계되어 있기 때문에)
> 의사결정은 다른 팀과의 협의를 거쳐서 이뤄져야 하기 때문이다.
>
> 도메인 주도 개발 p.382
