디스틸레이션(distillation) : 사전적인 의미로는 증류물, 정수 등의 의미를 가지며,
DDD에선 혼합된 요소를 분리해서 본질을 좀더 값지고 유용한 형태로 뽑는 과정을 의미한다.

> 갖가지 화학적인 증류 과정을 거치는 것과 마찬가지로 분리된 부산물은 그 자체로 증류과정을 거쳐
> 일반 하위 도메인(Generic Subdomain)과 응집력 있는 메커니즘(Coherent Mechanism)으로
> 더욱 의미 있는 형태가 되는데, 이러한 노력은 특별히 중요한 부분
> "Core Domain"(우리의 소프트웨어를 차별화하고 구축할 가치가 있게끔 만들어주는 부분)을 추출하려는 욕망에서 비롯된다.
>
> 도메인 주도 개발 p.428

도메인 모델에 대한 전략적 디스틸레이션에서는 아래와 같은 사항을 모두 수행한다.
1. 팀원들이 시스템의 전체 설계와 해당 설계가 어떻게 함께 조화될지 파악하게끔 돕는다.
2. Ubiquitous Language의 일부가 될 수 있게 관리 가능한 크기의 핵심 모델을 식별해서 의사소통을 촉진한다.
3. 리팩터링을 이끈다.
4. 가장 중요한 모델 영역의 업무에 초점을 맞춘다.
5. 아웃소싱, 기성 컴포넌트의 활용, 할당에 관한 의사결정을 돕는다.


### Core Domain
애플리케이션의 설계하는 목적들 중 특이하고 목적의 중요성을 강조하는 모델들을 Core Domain을 구성한다.
그러므로 다음과 같은 방향을 가지고 설계하자.
1. 모델을 요약한다.
2. Core Domain을 찾아 그것을 지원하는 다수의 모델과 코드로 부터 쉽게 구별하수 있는 수단을 제공하자.
3. Core Domain에 가장 가치 있고 전문화된 개념을 부각 시키자.
4. Core Domain은 최대한 작게 만들자.

#### Core Domain 선택 방법
> 어떤 Core Domain을 선택하느냐는 설계자의 관점에 달렸다.
> 예를 들어, 어떤 애플리케이션에서는 Core Domain인 것이 다른 애플리케이션에서는 일반화된 보조 Domain에 해당하기도 한다.
> 그럼에도 한 프로젝트, 보통 하나의 회사를 통틀어 하나의 일관된 Core가 정의 될수 있다.
> 설계의 다른 모든 부분과 마찬가지로 Core Domain을 파악하는 일은 반복주기를 거쳐 발전한다.
>
> 도메인 주도 개발 p.433

#### 누가 Core Domain을 설계하는 가?
> 오랜 기간 팀에 참여하고 도메인 지식 관심이 있는 능력 있는 개발자와
> 업무를 깊이 있게 알고 있는 여러 도메인 전문가로 팀을 구성한다.
>
> 도메인 주도 개발 p.433

### 일반 하위 도메인(Generic Subdomain)
> 현재 진행 중인 프로젝트를 위한 것이 아닌 응집력 있는 하위 도멘인을 식별하라.
> 이러한 하위 도메인에서 일반화된 모델 요소를 추출해서 별도 Module에 배치하라.
> 해당 Module에는 우리가 지정한 전문적인 지식(비즈니스 로직이나 Core Domain에 표함되는 지식)이
> 담긴 모델을 구현하지 않는다.
>
> 일단 하위 도메인이 분리되고 나면, 해당 하위 도메인에 대해서는 Core Domain보다는 낮은 우선순위를 부여하고
> 그 일에 핵심 개발자를 배치하지 않는다.(개발자가 거기서 비즈니스 관련 도메인 지식을 거의 얻지 못할 것이므로)
> 아울러 이러한 Generic Subdomain에 대해서는 기성 솔루션이나 공표된 모델을 고려해 본다.
>
> 도메인 주도 개발 p.436

#### 이러한 패키지를 구성 할때 몇가지 추가적인 선택사항.

##### 선택 1: 기성 솔루션(이미 구현된 제품을 구매하거나 오픈 소스를 이용)
유리한 점
- 개발할 코드가 적음
- 유지보수 부담이 외부화됨
- 코드가 좀더 성숙하고 다양한 곳에서 사용되므로, 사내에서 개발된 코드에 비해 실수가 적음

불리한 점
- 사용하기 전에 평가하고 이해나는 시간이 필요함
- 품질관리가 업계에서 이뤄지므로 올바르고 안정적일 거라 확실 할수 없음
- 용도에 비해 과도하게 만들어져 있을지도 모름, 최소주의적인 사내 구현에 비해 통합에 드는 노력이 클수도 있음
- 외부 요소는 대개 매끄럽게 통합되지 않음, 또한 외부 요소에는 별도의 Bounded Context가 있을지도 모른다.
  만약 그렇지 않더라도 다른 패키지의 Entity를 자연스럽게 참조하기가 쉽지 않을 수 있다.
- 플랫폼 의존성, 컴파일러 버전 의존성 등을 야기할 수도 있다.

##### 선택 2: 공표된 설계나 모델
유리한 점
- 사내 모델보다 더 성숙되고 많은 사람들의 통찰력을 반영
- 즉각적이고 높은 품질의 문서화

불리한 점
- 요구사항에 딱 맞지 않거나 과도한 설계일 수 있음

##### 선택 3: 외주제작된 구현
유리한 점
- 대부분의 지식이 필요하고 축적되는 Core Domain과 관련된 업무에서 핵심 팀을 해방시켜줌
- 팀을 영구히 확대하거나 Core Domain의 지식이 흩어져 없어지지 않고 더욱 많은 개발이 이뤄질 수 있음
- 명세가 외부로 전달돼야 하므로 힌터페이스 중심의 설계가 이뤄지고 하위 도메인을 일반화된 상태로 유지하는데 도움이 됨

불리한 점
- 인터페이스, 코딩 표준, 그리고 다른 모든 중요 측면을 대상으로 의사소통이 필요하므로
  여전히 핵심 팀에서 시간을 들여 구현을 사펴야함
- 코드를 이해해야 하기 때문에 소유권을 내부로 이전하는 데 상당한 부암이 야기됨(그럼에도 특화된 하위 도메인보다 부담이 덜함
  그 이유는 일반화된 모델은 이해하는데 특별한 예비 지식이 필요 없기 때문임)
- 코드 품질이 고르지 않음, 두 팀의 상대적 역량에 따라 코드의 품질이 좋거나 나쁠수 있음

##### 선택 4: 사내 구현
유리한 점
- 통합하기 쉬움
- 정확히 원하는 것만을 얻음
- 임시 계약자를 할당할 수 있음

불린한 점
- 계속되는 유지보수와 교육 부담
- 패키지 개발에 필요한 시간과 비용을 과소평가하기 쉬움
