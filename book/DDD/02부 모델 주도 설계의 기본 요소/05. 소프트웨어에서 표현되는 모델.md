## 연관관계(association)
연관관계를 다루는 효율적인 방법 3가지
1. 탐색 방향을 부여한다.
2. 한정자(qualifier)를 추가해서 사실상 다중성(multiplicity)을 줄인다.
3. 중요하지 않은 연관관계를 제거한다.

- 가능한 한 관계를 제약하는 것이 중요함.
- 양방향 연관관계는 두 객체가 모두 있어야(null이거나, Optional.empty하지 않아야 함) 이해 할수 있음.
- 애플리케이션 요구사항에 두 방향을 모두 탐색해야 한다는 요건이 없을 경우, __탐색 방향을 추가하면 상호 의존성이 줄어 들고 설계가 단순해짐__
- 구현하려는 도메인에 대해 심도있는 이해을 하게 되면 본연의 방향성이 들어 날지도 모
- 도메인을 더욱 깊이 있게 이해다 보면 굉장히 자주 "한정적인(qualified)"관계에 이른다.

## 엔티티(Entity)
- 어떤 객체를 일차적으로 해당 객체의 식별성을 정의할 경우 그 객체를 Entity라고 한다.
- Entity는 자신의 생명 주기 동안 형태와 내용이 급격하게 바뀔 수도 있지만 __연속성은 유지되어야 한다.__
- 개념적 식별성은 객체와 해당 객체의 저장 형태, 현실의 행위자(actor)의 구현 사이에서 일치해야 한다.
- 연속성을 가진 Entity를 추적하려면 그 Entity에 식별성이 정의 되어 있어야 한다.
- Entity의 클래스 정의와 책임, 속성, 연관관계는 그 속에 포함된 특정 속성 보다는 그 Entity가 내포하고 있는 정체성에 초첨을 맞춰 구현되어야 한다.

#### 엔티티의 식별성에 대해 이해 하기 위한 예시
> 경기장의 좌석을 예약하는 애플리케이션에서 좌석과 참석자를 Entity로 다룰수 있다.
> 지정석인 경우 각 입장권에는 좌석번호가 적혀 있을 것으므로 좌석이 Entity 이다. 
> __좌석의 식별자는 좌석번호 이므로 경기장 내에서 유일하다.__
> 좌석은 좌석의 위치나 시야가 가려지는 여부, 가격과 같은 다른 여러 속성을 포함하지만,
> 좌석을 식별하고 구분하는 데는 좌석번호가 유일하다.
>
> 한변 입장권을 가진 사람이 빈 좌석을 찾아 아무데나 앉을 수 있는 "일반석"이라면 개별 좌석을 구분하지 않아도 된다.
> 이 경우 전체 좌석의 개수만이 중요하다. 좌석 번호가 여전히 물리적인 좌석에 새겨져 있더라도 소프트웨어에서 그 번호를 관리할 필요는 없다.
> 이 경우 "일반석"은 Entity가 아니며 식별자는 필요 없다.
> 
> 도메인 주도 설계 - 95.p   

#### 엔티티의 식별성을 판단할 때 고려 사항
- __식별성은 원레 존재하지 않는 것이며, 필요에 의해 보충된 의미이다.__
- 한 객체가 속성보다는 식별성으로 구분될 경우, 모델 내에서 이를 해당 객체의 주된 정의(hashCode의 주된 키로 사용)로 삼자.
- 클래스 정의를 단순하게 하고, 생명주기의 연속성과 식별성에 집중하자.
- 객체의 형태나 이력에 관계없이 각 객체를 구별하는 수단을 정의하자.
- 객체의 속성으로 객체의 일치 여부를 판단하는 요구사항에 주의를 기울이자.
- 각 객체에 대해 유일한 결과를 반환하는 연산을 정의하자.
- 모델에서 식별성을 구분하는 방법이 일치해야 한다.(예를 들어 redis에 저장된 엔티티와 DB에 저장된 엔티티의 식별성은 같아야 한다.)

#### 엔티티의 모델링시 고려 사항
- Entity는 별도로 분리돼 있을 때 자신의 책임을 가장 잘 수행한다.
- 식별성 문제를 제외하면 Entity는 주로 자신이 소유한 객체의 연산을 조율해서 책임을 완수한다.

#### 식별 연산의 설계시 고려 사항
- 때때로 어떤 데이터 속성이나 여러 속성의 조합이 시스템 내에서 유일한 식별사로 사용될수 있다.
(예를 들어, 일간지의 경우 각 신문은 제목과 도시, 발행일로 구분할 수 있다.)
- 한 객체의 속성으로 구성되는 실질적인 고유키가 없다면 일반적인 해법으로 클래스 내에서 유일한 기호(숫자나 문자열)를 붙이는 것도 한 방법이다.
- 식별자의 유일성이 컴퓨터 시스템 범위를 넘어 적용되어야 할 때도 있다.( 예를 들어 외부 시스템과 연동 하는 경우 )


## 값 객체(Value Object)
식별자가 존재하진 않지만 사물을 서술하는데 사용되는 객체를 Value Object라고 한다.

> __"주소"는 Value Object 인가? (누가 묻는지에 따라 다르다.)__
> 
> 우편 주문 회사에서 사용하는 소프트웨어인 경우 신용카드를 확인하고 물건을 보낼 주소가 필요하다.
> 하지만 룸메이트도 같은 회사에 물건을 주문하더라도 두 사람이 같은 곳에 있다는 사실은 중요하지 않다.
> 이 경우 주소는 Value Object이다.
>
> 우편 서비스에서 사용하는 소프트웨어의 경우 배송 경로를 조직화하기 위해 그 나라를 지역, 도시, 우편 구역, 블록 개별 주소로 끝나는 형태로 만들수 있다.
> 이 같은 주소 객체는 계층구조상 부모로 부터 우편번호를 도출해 낼 수 있는데, 만약 서비스에서 배달 구역을 재할당하기로 했다면 거기에 속하는 모든 주소는 
> 부모 계층의 주소를 따라 바뀔 것이다. 이 경우 주소는 Entity다.
>
> 전기 설비 회사에서 사용하는 소프트웨어의 경우 주소는 전선 및 전기 공급의 목적지에 해당한다.
> 룸메이트가 각자 전기 점검을 요청한다면 전기 설비 회사에서는 점검 목적지를 파악할 필요가 있다.
> 이 경우 주소는 Entity이다.
> 아니면 모델에서 주소 속성이 포함된 Entity인 "거주지"와 설비 점검을 연관시킬수도 있다. 
> 이럴 경우 주소는 Value Object이다.
>
> 도메인 주도 설계 - 100.p   

#### 값 객체의 설계 
- 모델에 포함된 어떤 요소의 속성에마 관심이 있다면 그것을 Value Object로 분리하자.
- Value Object에서 전하는 속성의 의미를 표현하게 하고 관련 기능을 부여하자.
- Value Object는 가급적이면 완전 불변적(immutable)으로 다루자.
- Value Object에는 아무런 식별성을 부여 하지 말고 Entity를 유지하는데 필요한 설게상의 복잠성을 피하자.
(어떤 특정 상황에 종속된 처리를 피하고 순수하게 값에 대한 처리만 구현하자.) 
- 복사와 공유 어느것이 경제성면에서 더 나은지는 구현환경을 고려하여 생각해야 한다.
(복사의 경우 객체의 개수가 굉장히 많아져 시스템이 무거워 질수도 있지만 공유 또한 분산 시스템에서 느려 질수 있다.)

#### 값 객체 공유시 고려 사항
- 공간을 절약하거나 데이터 베이스 내의 객체 수를 줄이는 것이 중요한 경우
- 통신 부하가 낮은 경우(이를 테면 중앙 집중형 서버)
- 공유 객체의 불변성이 업격하게 지켜지는 경우

#### 값 객체의 불변성을 포기하고, 변경가능성을 허용하게 되는 경우
- value가 자주 변경되는 경우
- 객체 생성이나 삭제에 비용이 많이 드는 경우
- 교체(변경이 아닌)로 인해 클러스터링에 제한되는 경우
- value를 공유할 일이 그리 많지 않거나 클러스터링을 향상시키기 위해서나 다른 기술적인 이유로 공유가 보류된 경

#### Value Object를 포함한 연관관계 설계
- 모델에 포함된 연관관계의 수가 더 적고 연관관계가 단순할수록 더 나은 모델이라 할 수 있다.
- Value Object간의 양방향 연관관계는 완전히 제거하도록 노력해야 한다.
- 모델에 연관관계가 필요해 보여도 그 객체를 Value Object로 선언하는 것을 한번 더 생각하자.

## 서비스(Service)
- 활동(activity)나 행동(action)를 객체 지향적으로 모델링하는데 사용됨 
- Entity나 Value Object와는 달리 서비스를 정의하는 기준은 순전히 클라이언트에게 무엇을 제공(Ubiquitous Language를 통해 도출된 연산)할 수 있느냐에 있다. 
- 서비스는 대부분의 도메인 객체(Entity, Value Object)와 달리 자신의 행위에 대한 상태를 갖지 않는다.

#### 잘만들어진 서비스의 세가지 특징
1. 연산이 원래부터 Entity나 Value Object의 일부를 구성하는 것이 아니라 도메인 개념과 관련돼 있다.
2. 인터페이스가 도메인 모델의 외적 요소의 측면에서 정의된다.
3. __연산이 상태를 갖지 않는다.__
(여기서 상태를 갖지 않는 다는 것은 클라이언트가 특정 서비스 인스턴스의 개별 이력과는 상관없이 서비스의 모든 인스턴스를 사용할수 있다는 의미다.)


## 모듈 혹은 패키지(Module)
- 모듈은 하나의 __의사소통 메커니즘__이다.
- 분할되는 객체의 __의미_에 따라 모듈을 선택해야 한다.
- 어떤 클래스들을 한 모듈안에 함께 둔다는 것은 "동료 개발자에게 그 클래스를 하나로 묶어서 생각하자."는 말과 같다. 
- 모델이 어떤 이야기를 들려주는 것이라면 모듈은 이야기의 각 "장"에 해당한다.

#### 기술적인 정교함이 주도하는 패키지화 계획에 따르는 두가지 비용
1. 프레임워크의 분리 관례 탓에 개념적 객체를 구현하는 요소가 서로 떨어져 있으면, 더는 코드에서 모델이 드러나지 않는다.
2. 머릿속으로 다시 합칠 수 있을 만큼밖에 분할돼 읺지 안은데 프레임워크에서 그렇게 분할 된 결괄르 모조리 사용해 버리면 
도메인 개발들은 모델을 의미 있는 조각으로 나누는 능력을 잃어 버리게 된다.


### 객체가 아닌 요소를 객체지향 시스템에 혼합하는데, 생각해봐야 할 4가지
1. __구현 패러다임을 도메인에 억지로 맞추지 않는다.__  도메인에 과한 사고방식은 반드시 하나만 있는 것이 아니며, 패러다임에 어울리는 모델 개념을 찾아야 한다.
2. __유비쿼터스 언어에 의지한다.__ 각종 도구가 서로 엄밀한 관계에 있지 않더라도 언어를 매우일관데게 사용하여 설계의 각 부분에 분리되는 것을 방지하자.
3. __UML에 심취하지 말자.__ UML다이어그램에 집착해서 그리기 쉬운 방향으로 왜곡하려 들면 안된다. UML옆에 간단한 문장으로 설명을 써노흔 편이 외곡을 막는 방법일수 있다.
4. __비관적인 사고로 판단하자.__ 현재 사용하고 있는 도구가 제 몫을 하고 있는지 늘 의심하자.

