## 도메인 객체의 관리와 관련된 문제 2가지
1. 생명주기 동안의 무결성 유지하기
2. 생명주기 관리의 복잡성으로 모델이 난해해지는 것을 방지

아래와 같이 세가지 패턴을 사용하여 위의 문제를 해결한다.

### 1. 집합체(Aggregate)
#### 정의
- 데이터를 변경의 단위로 다루는 __연관 객체의 묶음__ 을 의미함
- 소유권(root)과 경계(boundary)를 명확히 정의함으로써 모델을 엄격하게 만들어 객체 간의 연관관계가 혼란스럽게 얽히지 않게 도와줌.
- 경계 안의 객체는 서로 협업(참조) 할 수 있지만, 경계 바깥에서는 객체의 Root(소유자)만을 참조 할수 있다. 
- 생명주기상의 전 단계에 걸쳐 도메인 객체의 무결성을 유지하는데 매우 중요한 역활을 담당함.


#### 불변식
불변식은 __데이터가 변경될 때마다 유지돼야 하는 일관적인 규칙__ 을 뜻하며, 이를 잘 구성하려면,
도메인을 심층적으로 이해하고 있어야 한다. 특히 특정 클래스의 인스턴스 사이의 변화 빈도와 같은 사향까지 이해하고 있어야 한다. 
또한, 높은 결합 지점은 느슨하게 하고, 엄격한 분변식을 더욱 엄격하게 지켜지게 하는 모델을 찾을 필요가 있다.

#### 집합체(Aggregate) vs 구성(Composition)
객체를 조립할때 어떤 행위에 집중하는 냐에 따라 
부르는 용어가 다른것 같다. 
일단 Aggregate는 조립 행위가 진행되고 나서
그 조립체(집합체)가 행동하는 관점을 의미하므로
Aggregate Root를 찾는 것이 주요한 의미를 갖는다.(JPA Entity)

이 개념을 토대로 추후에 Repository를 기준으로 객체를 선정해서 관리하는 목적에 주안점을 둔다.
반면,  Composition은 객체 조립하는 행위 관점만을 주요 관심사로 생각할때 쓰는 용어로 생각된다.
그래서, Composition을 생각할 때는 Factory, Builder 패턴과 같이 조립을 품위 있게 하는 패턴들과 같이 설명된다.



### 2. 팩터리(Factory)
#### 정의
- Factory의 책임은 만들어 내는 객체가 불변식이 충족되도록 보장하는 것이다.
- 복잡한 객체 집합(Aggregate)를 생성하고 재구성하는 것을 도와줌
- 각 객체들에 대한 효율적인 캡슐화를 지원함

> 복잡한 객체와 Aggregate의 인스턴스를 생성하는 책임을 별도의 객체로 옮겨라.(factory 클래스를 설계하자.)
> 이 객체자체는 도메인 모델에서 아무런 책임도 맡지 않을 수도 있지만, 여전히 도메인 설계의 일부를 구성한다.
> 모든 복잡한 객체 조립 과정을 캡슐화하는 동시에 클라이언트가 인스턴스화되는 객체의 구상 클래스를 참조 할 필요가 ㅇ벗는 인터페이스를 제공하자.
> 전체 Aggregate를 하나의 단위로 생성해서 __그것의 불변식이 이행되게 하자.__
>  
> 도메인 주도 설계 142.p

#### Factory를 잘 설계하기 위한 조건
1. 각 생성 방법은 원자적(atomic)이어야 한다.
2. 생성된 객체는 Aggregate의 불변식을 모두 지켜야 한다.
3. Factory는 일관성 있는 상태에서만 객체를 만들어 낼수 있어야 한다. 
4. 불변적인 Value Object의 경우에는 모든 속성이 올바른 최종 상태로 초기화되어야 한다.
5. 인터페이스를 통해 올바르게 객체를 생성 할 수 없다면, 예외가 발생하거나 또는 다른 어떤 메커니즘이 작동해서, 더는 적절하지 않은 반환값을 사용할수 없도록 보장해야 한다. 
6. Factory는 생성된 클래스보다는 생성하고자 하는 타입으로 추상화돼야 한다.
7. Factory는 만들어내는 객체와 매우 강하게 결합돼 있으므로 Factory는 자신의 생성물과 가장 밀접한 관계에 있는 객체에 있어야 한다.

#### 공개 생성자(public constructo)만으로 충분히 Factory역활을 대체 하는 경우
- 클래스가 타입인 경우, 클래스가 어떤 계층구조의 일부를 구성하지 않으며, 인터페잇를 구현하는 식으로 다형적으로 사용되지 않는 경우.(값 객체인 경우)
- 클라이언트가 Strategy를 선택하는 한 방법으로서 구현체에 관심이 있는 경우
- 클라이언트가 객체의 속성을 모두 이용할 수 있어서 클라이언트에게 노출된 생성자 내에서 객체 생성이 중첩되지 않는 경우
- 생성자가 복잡하지 않은 경우
- 불변 객체를 생성해야 되는 경우( static method를 사용하여 생성하ㅏ려는 의도롤 좀더 명확하게 표현할 수 있음)

#### Factory 인터페이스를 설계할때 주의 사항
- __각 연산은 원자적이어야 한다.__ 복잡한 생성물을 만들어내는데 필요한 것은 모두 한번에 Factory로 전달해야 한다.
- __Factory는 자신에게 전달된 인자와 결합될 것이다.__ 인자가 단순히 생성물에 들어가는 것이라면 가장 의존성이 적당한 상태이나 인자를 끄집어 내서 객체 생성과정에 한다면 결합은 더 강해진다.

#### Entity Factory vs Value Object Factory
- Entity Factory는 유효한 Aggreegate를 만들어 내는데 필요한 속성만 받아 경향이 있음
- Value Object는 불변적이므로 생성물이 완전히 최종적인 형태로 만들어 진다. 그러므로 Factory의 연산은 생서물에 대해 풍부한 설명이 필요하다.

#### 저장된 객체를 재구성할때 생각해 볼만한 사항 2가지
1. __재구성에 사용된 Entity Factory는 새로운 ID를 할당하지 않는다.__ 그 이유는 이전에 객체를 실체화(incarnation)했던 것과의 연속성을 잃어 버린다.
따라서 저장된 객체를 재구성하는 Factory의 입력 매개변수에는 반드시 식별 속성을 포함해야 한다.
2. __객체를 재구성하는 Factory는 불변식 위반을 다른 방식으로 처리한다.__ 재구성이 일어나는 동안에는 탄력적으로 대응해야 한다.
새로운 객체를 생성하는 것보다 휠씬 더 재구성을 어렵게 만들수 있는 불일치 문제를 해결 하기 위한 전략을 어느 정도 마련해야 한다.

### 3. 리파지터리(Repository)
- 객체의 영속성을 관리(메모리상에 커다란 컬렉션이 있다고 착각을 불러 일으키는 객체를 만듬)
- __Aggregate 내부에 존재하는 모든 객체는 루트의 인터페이스를 통해서만 접근되어야 한다.__
- 특정한 기준으로 객체를 선택하고 속성값이 특정 기준을 만족하는 완전히 인스턴스화된 객체나 객체 컬렉션을 반환하는 메서드를 제공함으로써 실제 저장소와 질의 기술을 캡슐화 함

#### 재구성(reconstitution) : 저장된 객체로 부터 인스턴스를 만들어 내는 구성법

> 영속 객체는 해당 객체의 속성에 근거해서 검색하는 식으로 전역저으로 접근 할 수 있어야 한다. 그러나 접근 방식이 필요한 곳은 탐색으로
> 도달하기에는 편리하지 않은 Aggregate의 루트다. 일반적으로 루트는 Entity이며, 간혹 복잡한 내부 구조를 지닌 Value Object이거나
> 열거형 Value이기도 하다. 다른 객체에도 접근할 수 있게 한다면 중요한 구분법이 혼동될 것이다.
> 마음대로 데이터베이스에 질의를 수행하면 실제로 도메인 객체와 Aggregate의 캡슐화를 어길 수도 있다.
> 기술적 인프라스트럭처와 데이터베이스 접근 메커니즘을 드러내면 클라이언트가 복잡해져서 Model-Driven Design이 불분명해질 것이다.
> 
> 도메인 주도 설계 p. 155

#### Repository의 이점
- 영속화된 객체를 획득하고 해당 객체의 생명주기를 관리하기 위한 단순한 모델을 클라이언트에게 제시
- 영속화 기술과 다수의 데이터베이스 전략, 또는 다수의 데이터 소스로 부터 애플리케이션과 도메인 설계를 분리
- 객체 접근에 관한 설계 결정을 전해 줌
- 테스트에서 사용할 가짜 구현체로 손쉽게 대체 가능(보통 메모리상의 컬렉션을 이용함)

#### Repoitory의 개념을 여러 사항에 적용할 때, 고려해야 하는 몇가지 중요사항
- __가급적 타입을 추상화 하라.__ 
- __클라이언트와의 분리를 활용하자.__ 
- __트랜잭션 제어를 클라이언트에 둔다.__ 데이터 베이스에 대한 삽입과 삭제를 Repository에서 수행하겠지만 보통 Repository에서는 아무것도 commit하지 않는다.
(Repository에서 간섭하지 않는다면 트랜잭션 관리가 좀더 단순해 짐)