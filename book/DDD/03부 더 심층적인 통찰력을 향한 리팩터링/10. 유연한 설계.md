> 개발이 진행될수록 현재의 레거시 코드로 인한 중압감에 시달리지 않고 프로젝트 진행을 촉진하려면 변경을 수용하고 즐겁게 작업 할수 있는 설계가 필요하다.
> 바로 __유연한 설계(supple design)__ 가 그것이다.
>
> 유연한 설계는 심층 모델링을 보안한다. 암시적인 개념을 찾아내서 이를 명확하게 표현했다면 일단 심층 모델을 만들 원재료는 갖춘셈이다.
> 반복주기를 거쳐 핵심 관심사를 단순하고도 명확하게 표현하는 모델을 개발하고, 클라이언트 개발자가 모델을 실제 작동 가능한 코드로 만들어
> 낼수 있는 설계를 구성함으로써 이 재료를 유용한 형태로 만든다.
> __설계와 코드를 작성하는 과정에서 모델에 포함된 개념을 개선할 수 있는 통찰력을 얻게 된다.__
>
> 무수히 많은 과도한 엔지니어링이 유연성이라는 명목으로 정당회돠어 왔다.
> 그러나 대개 너무 과도한 추상 계층과 간접 계층이 존재하면 오히려 유현성에 방해가 된다.
>
> 사용자에게 유용성을 제공하는 소프트웨어의 설계를 살펴보면, 일반적으로 뭔가 __단순한 것__ 을 보게 된다.
>
> __단순하다는 것__ 이 쉽다는 것을 의미하지는 않는다.
>
> 정교한 시스템을 만들 목적으로 조립가능하고 그럼에도 이해하기 어렵지 않은 요소를 만들어 내려면,
> Model Driven Design을 적당한 수준의 엄밀한 설계 형식과 접목하고자 하는 노력이 필요 하다.
>
> 도메인 주도 개발 p.258


#### 의도를 드러내는 인터페이스(Intention Revealing Interface)
- 우리는 언제나 인지 과부하(cognitive overload)와의 힘겨운 투쟁을 벌어야 한다.
- 설계에 포함된 모든 공개 요소가 조화를 이뤄 인터페이스를 구성하고, 인터페이스를 구성하는 각 요소의 이름을
  토대로 설계 의도를 드러 낼수 있는 기획을 얻도록 설계해야 한다.


#### 부작용(부수효과)이 없는 함수(Side Effect Free Function)
- 부수효과를 일으키지 않으면서 결과를 반환하는 연산을 __함수(function)__ 라고 하며,
  함수는 여러번 호출해도 무방하며 매번 동일한 값을 반환한다.

> 대부분의 소프트웨어 시스템에서 명령을 사용하지 않기란 불가능하지만 다음의 두가지 방법으로
> 문제를 완화할 수 있다.
>
> 첫째, 명령과 질의를 엄격하게 분리된 서로 다른 연산으로 유지하는 것이다.
> 변경을 발생시키는 메서드(setter)는 도메인 데이터를 반환하지 않아야 하고, 가능한 한 단순하게
> 유지해야 한다. 모든 질의와 계산을 관찰 가능한 부수효과를 발생시키지 않는 메서드 내에서 수행해야 한다.
>
> 둘째, 기존의 객체를 전혀 변경하지 않고도 문제를 완호할 수 있는 대안적인 모델과 설계가 있다.
> 명령과 질의를 분리하는 대신 연산의 결과를 표현하는 새로운 Value Object를 생성해서 반환한다.
> __생명주기를 신중하게 통제해야 하는 Entity와는 달리 Value Object는 질의에 대한 응답을 생성하고, 반환한 후 잊어 버리면 된다.__
>
> 도메인 주도 개발 p.267

```java
class Paint{
  private double volume;
  private int red;
  private int yellow;
  private int blue;
  // 변경을 발생시키는 메서드( 도메인 데이터를 가급적이면 반환하지 않아야 하고, 최대한 단순하게 유지 하자.)
  public void mixIn(Paint other){
    volume = volume.plus(other.getVolume());
    // 새로운 빨강, 파랑, 노랑 값을 할당하는
    // 많은 양의 복잡한 색상 혼합 코드가 이어짐
  }
}
```
현재 다루고자 하는모데인에서 색상은 중요한 개념이다.
색상이라는 개념을 명시적인 객체로 만들어서 개념을 분리하여 의사전달이 더 명확해 지도록 구성하자.


```java
final class PigmentColor{
  private final int red;
  private final int yellow;
  private final int blue;
  private PigmentColor(int red, int yellow, int blue){
    this.red = red;
    this.yellow = yellow;
    this.blue = blue;
  }
  public static PigmentColor mixedWith(PigmentColor other, double ratio){
    // 새로운 빨간, 파랑, 노랑 값을 할당하는 많은 양의 복잡한 색상 혼합 코드가 이곳에 구현됨
  }
}

class Paint{
  private double volume;
  private PigmentColor pigmentColor;

  public PigmentColor pigmentColor() {
    return pigmentColor;
  }

  // 변경을 발생시키는 메서드( 도메인 데이터를 가급적이면 반환하지 않아야 하고, 최대한 단순하게 유지 하자.)
  public void mixIn(Paint other){
    volume += other.getVolume();
    double ratio = other.getVolume() / volume;
    pigmentColor = pigmentColor.mixedWith(other.pigmentColor(), ratio);
  }
}
```


### 단언(Assertion)
- 절차를 기술하지 않고 상태만 기술함

페인트 구현 예제에서 ```mixIn```메서드가 동작하면 다음과 상태를 갖는다.
- ```p1.mixIn(02)```을 실행하고 나면 :
  - ```p1.volume```은 ```p2.volume```만큼 증가함
  - ```p2.volume```은 변경되지 않음

> 문제는 사후 조건에 기술된 특성이 개발자들이 페인트 혼합에 관해 사고하는 개념과 일치하지 않아 실수를 저지르게 된다는 점이다.
>
> 위와 같은 사항으로 아래와 같은 불변식이 유추 된다.
> __페인트를 혼합하면, 혼합(mixIn)에 참여한 모든 페인트의 용량은 변하지 않는다.__
>
> 이 애플리케이션의 최종 목적은 사용자가 어떤 페인트를 혼합물에 넣어야 할지 판단하는 것을 돕는 것이다.
>
> 따라서 논리적으로 일관성 있는 페인트의 용량 모델을 구축한다면 애플리케이션의 요구사항을 만족 시킬수 없을 것이다.
> 세상의 모든것이 직관적이지 않으므로 이렇게 하는 편이 최선의 방법일 때도 있다.
> 하지만 이 경우에는 부자연스러움의 원인은 "놓쳐버린 내부 개념(깊이 숨어 있는 개념)" 때문이다.
> 그러므로, __새로운 모델을 찾아야 한다.__
>
> 더 나은 모델을 조사할 때는 최초의 설계 이후로 행해진 지식 탐구와 더 심층적인 통찰력을 향한 리팩터링으로 원래의 설계자보다
> 유리한 위치에 설 수 있다.
> 예를 들어, Value Object에 기반을 둔 Side-effect-free Function을 사용해서 색상을 계산한다.
>
> 도메인 주도 개발 p.275

```java
interface Paint{
  double getVolume();
  PigmentColor getColor();
}

@Value
class StockPaint implements Paint{
  private double volume;
  private PigmentColor pigmentColor;
}

class MixedPaint implements Paint{
  private Set<StockPaint> stockPaints;

  public void mixIn(StockPaint StockPaint){
    // 단순히 새로운 페인트를 구성요소 컬렉션(Set<StockPaint>)에 추가
  }
  @Overried
  public double getVolume(){
    // 구성요소(Set<StockPaint>)의 용량(volume)의 합을 반환함
  }
  @Overried
  public PigmentColor getColor(){
    // PigmentColor의 mixedWith()를 이용해 구성요소의 색상을 혼합한 결과를 계산하고 결과값을 반환
  }
}
```
이제 명령(command)은 ```mixIn()```하나밖에 없다. ```mixIn()```은 단지 객체를 커렉션에 추가할 뿐이고,
그에 따른 결과는 모델을 직관적으로 이해한 경우, __매우 명확해 진다.__

Assertion중 한 가지를 확인하는 테스트 메서드는 다음과 같다.
```java
public void testMixingVolume(){
  PigmentColor yellow = new PigmentColor(0, 50, 0);
  PigmentColor blue = new PigmentColor(0, 0, 50);

  MixedPaint mix = new MixedPaint();

  mix.mixIn(new StockPaint(1.0, yellow));
  mix.mixIn(new StockPaint(1.5, blue));

  assertEquals(2.5, mix.getVolume(), 0.01);
}
```

이 모델은 도메인에 관한 좀더 풍부한 정보를 포함하고 전달한다. 불편식과 사후조건이 의미하는 바와 일맥상통하며,
결과적으로 모델을 유지보수하고 사용하기 쉬워질 것이다.


### 개녑적 윤곽(Conceptual Contour)
> 각 도메인 어딘가에는 나름의 논리가 존재한다.
> 도메인에는 잠재적인 일관성이 존재하므로 도메인의 일부 영역에서 적절한 모델을 발견하면
> 이 모델이 나중에 발견되는 다른 영역과도 일관성을 유지할 가능성이 높다.
> 때때로 새로 발견된 영역을 기존 모델에 조화시키기 어려운 경우도 있지만
> 이러한 경우 더 심층적인 통찰력이 반영된 모델을 향해 리팩터링하고
> 다음번 발견에서는 조화로워질 거라 기대할 수 있다.
>
> 이것이 바로 반복적인 리팩터링을 통해 유연한 설계를 얻게 되는 이유 중 하나이다.
> 이처럼 새로 알게된 개념이나 요구사항을 코드에 적용하다 보면 개념적 윤곽(Conceptual Contour)가 나타난다.
>
> 도메인 주도 개발 p.277
>
>
> 도메인의 중요 영역을 나누는 것과 관련한 직관을 키워서 설계요소(연산, 인터페이스, 클래스, Aggregate)를
> 응집력 있는 단위로 분해 하자. 계쏙적인 리펙토링을 토대로 변경되는 부분과 변경되지 않는 부분을 나누는 중심 축을
> 식별하고, 변경을 분리하기 위한 패턴을 명확하게 표현하는 Conceptual Contour를 찾자.
>
> 도메인 주도 개발 p.278
>
>
> Intention-Revealing Interface 는 클라이언트가 단순 메커니즘이 아닌 의미 단위로 객체를 제공하게 해 준다.
> Side-effect-free function과 Assertion은 그러한 단위를 사용해 복잡한 조합을 만들는 일을 안전하게 만든다.
> 이러한 Conceptual Contour의 출현으로 모델의 각 부분은 안전화될뿐더러 각 단위는 직관적으로 사용하고 조합할 수 있게 된다.

### 독립형 클래스(Standalone Class)
> Module내에서 조차 의존성이 증가할수록 설계를 파악하는 데 따르는 어려움이 가파르게 높아진다.
> 이는 개발자에게 정신적 과부하(mental overload)를 줘서 개발자가 다룰 수 있는 설계의 복잡도를 제한한다.
> 아울러 명시적인 참조에 ㄷ비해 암시적인 개념이 훨씬 더 많은 정신적 과부하를 초래한다.
>
> 도메인 주도 개발 p.283
>
>
> 낮은 결합도는 객체 설계의 기본 원리이다. 가능한 한 늘 결합도를 낮추고자 노력하자.
> 현재 상황과 무관한 모든 개념을 제거하자. 그러면 클래스가 완전히 독립적(self-contained)으로
> 바뀌고 단독으로 검토하고 이해할 수 있다. 그러한 독립적인 클래스는 Module을 이해하는 데 따르는 부담을 상당히 덜어 준다.
>
> 도메인 주도 개발 p.284


### 연산의 닫힘(Closure Of Operation)
> 두 실수를 곱하면 실수가 나온다. [모든 실수는 유리수인 동시에 무리수다.] 실수를 곱하면
> 실수가 나온다는 것은 항상 참이므로 실수를 가리켜 __"곱셈에 대해 닫혀 있다"__ 라고 한다.
> 즉, 실수를 곱한 결과가 실수 집합에 포함되지 않는 경우는 존재하지 않는다.
> 실수 집합에 포힘된 임의의 두 수를 결합한 결과 역시 항상 실수 집합에 포함된다.
>
> -- 수학 포럼, 드렉셀 대학(Drexel University)
>
> - 실수(real number) : 주로 실 직선 위의 점 또는 십진법 전개로 표현되는 수 체계를 의미함
>   사칙연산(덧셈, 뺄샘, 곱셈, 나눗셈)을 실행할수 있으며, 실수는 크기 비교가 가능함, 또한
>   실 직선상에서 더 왼쪽에 있는 수가 더 오른쪽에 있는 수 보다 작다.
>   즉, 실수는 0보다 큰 양수, 0보다 작은 음수 0으로 분류 된다.
>
> - 유리수(rational number) : 두 정수의 분수 형태(단 분모는 반드시 0이 아님)로 나타낼수 있는 실수를 의미함
> - 무리수(irrational number) : 두 정수의 비의 형태로 나타 낼수 없는 실수를 의미함, 즉 분수로 나타낼수 없는 소수를 의미함
>   무리수는 소숫점 이하로 같은 수의 배열이 반복적으로 나타나지 않는(순환하지 않는) 무한 소수이다.(ex> 파이(3.14......))
