> 개발이 진행될수록 현재의 레거시 코드로 인한 중압감에 시달리지 않고 프로젝트 진행을 촉진하려면 변경을 수용하고 즐겁게 작업 할수 있는 설계가 필요하다.
> 바로 __유연한 설계(supple design)__ 가 그것이다.
>
> 유연한 설계는 심층 모델링을 보안한다. 암시적인 개념을 찾아내서 이를 명확하게 표현했다면 일단 심층 모델을 만들 원재료는 갖춘셈이다.
> 반복주기를 거쳐 핵심 관심사를 단순하고도 명확하게 표현하는 모델을 개발하고, 클라이언트 개발자가 모델을 실제 작동 가능한 코드로 만들어
> 낼수 있는 설계를 구성함을쏘 이 재료를 유용한 형태로 만든다.
> __설계와 코드를 작성하는 과정에서 모델에 포함된 개념을 개선할 수 있는 통찰력을 얻게 된다.__
>
> 무수히 많은 과도한 엔지니어링이 유연성이라는 명목으로 정당회돠어 왔다.
> 그러나 대개 너무 과도한 추상 계층과 간접 계층이 존재하면 오히려 유현성에 방해가 된다.
>
> 사용자에게 유용성을 제공하는 소프트웨어의 설계를 살펴보면, 일반적으로 뭔가 __단순한 것__ 을 보게 된다.
>
> __단순하다는 것__ 이 쉽다는 것을 의미하지는 않는다.
>
> 정교한 시스템을 만들 목적으로 조립가능하고 그럼에도 이해하기 어렵지 않은 요소를 만들어 내려면,
> Model Driven Design을 적당한 수준의 엄밀한 설계 형식과 접목하고자 하는 노력이 필요 하다.
>
> 도메인 주도 개발 p.258

#### 의도를 드러내는 인터페이스(Intention Revealing Interface)
- 우리는 언제나 인지 과부하(cognitive overload)와의 힘겨운 투쟁을 벌어야 한다.
- 설계에 포함된 모든 공개 요소가 조화를 이뤄 인터페이스를 구성하고, 인터페이스를 구성하는 각 요소의 이름을
  토대로 설계 의도를 드러 낼수 있는 기획을 얻도록 설계해야 한다.

#### 부작용(부수효과)이 없는 함수(Side Effect Free Function)
- 부수효과를 일으키지 않으면서 결과를 반환하는 연산을 __함수(function)__ 라고 하며,
  함수는 여러번 호출해도 무방하며 매번 동일한 값을 반환한다.

> 대부분의 소프트웨어 시스템에서 명령을 사용하지 않기란 불가능하지만 다음의 두가지 방법으로
> 문제를 완화할 수 있다.
>
> 첫째, 명령과 질의를 엄격하게 분리된 서로 다른 연산으로 유지하는 것이다.
> 변경을 발생시키는 메서드(setter)는 도메인 데이터를 반환하지 않아야 하고, 가능한 한 단순하게
> 유지해야 한다. 모든 질의와 계산을 관찰 가능한 부수효과를 발생시키지 않는 메서드 내에서 수행해야 한다.
>
> 둘째, 기존의 객체를 전혀 변경하지 않고도 문제를 완호할 수 있는 대안적인 모델과 설계가 있다.
> 명령과 질의를 분리하는 대신 연산의 결과를 표현하는 새로운 Value Object를 생성해서 반환한다.
> __생명주기를 신중하게 통제해야 하는 Entity와는 달리 Value Object는 질의에 대한 응답을 생성하고, 반환한 후 잊어 버리면 된다.__
>
> 도메인 주도 개발 p.267

```java
class Paint{
  private double volume;
  private int red;
  private int yellow;
  private int blue;
  // 변경을 발생시키는 메서드( 도메인 데이터를 가급적이면 반환하지 않아야 하고, 최대한 단순하게 유지 하자.)
  public void mixIn(Paint other){
    volume = volume.plus(other.getVolume());
    // 새로운 빨강, 파랑, 노랑 값을 할당하는
    // 많은 양의 복잡한 색상 혼합 코드가 이어짐
  }
}
```
현재 다루고자 하는모데인에서 색상은 중요한 개념이다.
색상이라는 개념을 명시적인 객체로 만들어서 개념을 분리하여 의사전달이 더 명확해 지도록 구성하자.


```java
final class PigmentColor{
  private final int red;
  private final int yellow;
  private final int blue;
  private PigmentColor(int red, int yellow, int blue){
    this.red = red;
    this.yellow = yellow;
    this.blue = blue;
  }
  public static PigmentColor mixedWith(PigmentColor other, double ratio){
    // 새로운 빨간, 파랑, 노랑 값을 할당하는 많은 양의 복잡한 색상 혼합 코드가 이곳에 구현됨
  }
}

class Paint{
  private double volume;
  private PigmentColor pigmentColor;

  public PigmentColor pigmentColor() {
    return pigmentColor;
  }

  // 변경을 발생시키는 메서드( 도메인 데이터를 가급적이면 반환하지 않아야 하고, 최대한 단순하게 유지 하자.)
  public void mixIn(Paint other){
    volume += other.getVolume();
    double ratio = other.getVolume() / volume;
    pigmentColor = pigmentColor.mixedWith(other.pigmentColor(), ratio);
  }
}
```

#### 단언(Assertion)
- 절차를 기술하지 않고 상태만 기술함

페인트 구현 예제에서 ```mixIn```메서드가 동작하면 다음과 상태를 갖는다.
- ```p1.mixIn(02)```을 실행하고 나면 :
  - ```p1.volume```은 ```p2.volume```만큼 증가함
  - ```p2.volume```은 변경되지 않음

> 문제는 사후 조건에 기술된 특성이 개발자들이 페인트 혼합에 관해 사고하는 개념과 일치하지 않아 실수를 저지르게 된다는 점이다.
>
> 위와 같은 사항으로 아래와 같은 불변식이 유추 된다.
> __페인트를 혼합하면, 혼합(mixIn)에 참여한 모든 페인트의 용량은 변하지 않는다.__
>
> 이 애플리케이션의 최종 목적은 사용자가 어떤 페인트를 혼합물에 넣어야 할지 판단하는 것을 돕는 것이다.
>
> 따라서 논리적으로 일관성 있는 페인트의 용량 모델을 구축한다면 애플리케이션의 요구사항을 만족 시킬수 없을 것이다.
> 세상의 모든것이 직관적이지 않으므로 이렇게 하는 편이 최선의 방법일 때도 있다.
> 하지만 이 경우에는 부자연스러움의 원인은 "놓쳐버린 내부 개념(깊이 숨어 있는 개념)" 때문이다.
> 그러므로, __새로운 모델을 찾아야 한다.__
>
> 더 나은 모델을 조사할 때는 최초의 설계 이후로 행해진 지식 탐구와 더 심층적인 통찰력을 향한 리팩터링으로 원래의 설계자보다
> 유리한 위치에 설 수 있다.
> 예를 들어, Value Object에 기반을 둔 Side-effect-free Function을 사용해서 색상을 계산한다.

```java
interface Paint{
  double getVolume();
  PigmentColor getColor();
}

@Value
class StockPaint implements Paint{
  private double volume;
  private PigmentColor pigmentColor;
}

class MixedPaint implements Paint{
  private Set<StockPaint> stockPaints;

  public void mixIn(StockPaint StockPaint){
    // 단순히 새로운 페인트를 구성요소 컬렉션(Set<StockPaint>)에 추가
  }
  @Overried
  public double getVolume(){
    // 구성요소(Set<StockPaint>)의 용량(volume)의 합을 반환함
  }
  @Overried
  public PigmentColor getColor(){
    // PigmentColor의 mixedWith()를 이용해 구성요소의 색상을 혼합한 결과를 계산하고 결과값을 반환
  }
}
```
이제 명령(command)은 ```mixIn()```하나밖에 없다. ```mixIn()```은 단지 객체를 커렉션에 추가할 뿐이고,
그에 따른 결과는 모델을 직관적으로 이해한 경우, __매우 명확해 진다.__

Assertion중 한 가지를 확인하는 테스트 메서드는 다음과 같다.
```java
public void testMixingVolume(){
  PigmentColor yellow = new PigmentColor(0, 50, 0);
  PigmentColor blue = new PigmentColor(0, 0, 50);

  MixedPaint mix = new MixedPaint();

  mix.mixIn(new StockPaint(1.0, yellow));
  mix.mixIn(new StockPaint(1.5, blue));

  assertEquals(2.5, mix.getVolume(), 0.01);
}
```

이 모델은 도메인에 관한 좀더 풍부한 정보를 포함하고 전달한다. 불편식과 사후조건이 의미하는 바와 일맥상통하며,
결과적으로 모델을 유지보수하고 사용하기 쉬워질 것이다.
