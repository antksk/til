## RESTful 개요
- 모든 리소스를 URI로 구별할 수 있다.
- 모든 리소스는 복수의 형태로 나타낼수 있다.
- 모든 리소스는 HTTP표준 메소드를 이용하여, 접근/수정/생성/삭제 할수 있다.
- 서버에는 어떠한 상태 정보도 갖고 있지 않다.

## 리차드슨 성숙도 모델

### 레벨0 : 원격 프로시저 호출
POST메소드만 사용하여 서비스 간에 단일 POST 메소드 데이터를 교환한다.
초창기 SOA애플리케이션 제작시 흔히 사용된 방식임

### 레벨1 : REST 리소스
파라미터를 넘기는 대신 REST URI를 이용한다.
레벨0처럼 POST메소드 하나밖에 사용하지 않지만,
POST메서드로 서비스 간 통신을 하면서 복잡한 기능을  
여러 리소스로 분산시킨다는 점에서 한 단계 발전된 형태이다.

### 레벨2 : 추가 HTTP메서드
POST외에 GET, HEAD, DELETE, PUT메서드를 추가적으로 사용
이와 같이 여러 메서드를 사용하여 다양한 리소스 접근 방식을 제공함

### 레벨3 : HATEOAS(Hypermedia as the Engine of Application State)
애플리케이션 상태 엔진으로서의 하이퍼미디어(HATEOAS)는 요청에 대한 하이퍼미디어 응답 속에 클라이언트가
다음에 취해야 할 액션에 관한 상태 정보가 담겨 있다.
이와 같이 설계되면 리소스에 대한 발견 가능성(discoverability)이 높아진다.


## 안전한 메서드(safe methods)
서버 측에 상태 정보를 변경하지 않는 메소드를 의미
> GET, HEAD와 같은 안전한 메소드는 캐시가 가능하다.
> PUT, POST, DELETE는 리소스를 변경하므로 안전한 메소드가 아니다.

## 멱등한 메서드(idempotent methods)
몇 번을 호출되더라도 동일한 결괄르 리턴하는 메소드를 의미
> 멱등한 메소드
> - GET 메서드 : 여러번 호출해도 타킷 리소스가 동일
> - PUT 메서드 : 동일한 요청에 대해 업데이트가 동일함
> - DELETE 메서드 : 첫 시도시 요청한 리소스를 삭제한 후 존재하지 않는 리소스에 대해,
> 삭제 요청을 하므로 반환되는 결과가 동일함
>
> 멱등하지 않은 메서드
> - POST 메서드 : 복수 호출시 각기 다른 결과를 반환하거나 새로운 리소스를 계속 생성함


## RESTful 서비스의 설계 원칙
- 리소스 URI 결정 :
  어떤 명사(nouns)로 리소스를 나타낼지 결정
- 리소스 메소드 결정 :
  CRUD에 해당하는 여러 가지 HTTP메소드를 사용
  - GET : 단순한 형태의 리소스 접근 역활을 담당(READ), 멱등한 메소드 이며 요청 문자열끝에 쿼리 파라미터(query parameter)를 붙임
  - HEAD : GET과 유사하지만 콘텐츠가 아닌 HTTP헤더만 리턴함
  - POST : POST요청을 여러 번 사용하면 여러 갯의 리소스가 생성 되므로 멱등하지 않은 메소드임, 권고사항으로 쿼리 파라미터를 사용하지 않는 것이 좋음
  - PUT : 이미 생성된 리소스를 수정(변경)할때 사용되며 멱등하지만 안전하지 않은 메소드 임
  - DELETE : 리소스를 삭제 하는 메소드로 멱등하지만 안전하지 않음
  - PUS vs POST
    Request-URI 형태가 다름, 예를 들어 ```POST /v1/coffess/orders```는 주문 데이터를 생성하고,
    리소스를 생성한뒤 생성된 리소스를 가르키는 식별자를 반환하지만, ```PUT /v1/coffess/orders/1234```는
    요청한 주문번호 1234의 리소스가 존재하면 업데이트, 존재하지 않은 경우, 1234인 데이터를 생성함
- 리소스 표현형(representation)결정 :
  JSON, XML, HTML, 일반 텍스트 중 어떻게 리소스를 표현할지 선택
- JAX-RS API 기반 RESTful 서비스 구현
  API 구현은 JAX-RS명세에 따름
- RESTful 서비스 배포
- RESTful 서비스 테스팅


## 리소스 설계에 관한 베스트 프랙티스
- API 개발자는 명사와 HTTP메소드를 사용하여 리소스를 구별하고 이해하기 쉬운 형태로 설계해야 한다.
  예를 들어, ```/user/1234/getBook```보다는 ```/user/1234/books```가 더 낫다.
- 서브 리소스는 URI를 연관지어 구별되도록 한다.
  예를 들어, ID가 1234인 유저에 대한 5678번 책의 저자 정보는
  ```/user/1234/books/5678/authors```와 같은 형태를 취한다.
  - 그 밖의 조건은 쿼리 파라미터로 지정한다. 예를 들어, 10개 이상의 리뷰가 달린 도서 목록을 조회하는 경우
    URI는 ```/user/1234/books?reviewsCount=10```
- 응답 레코드의 일부만 필요한 경우 쿼리 파라미터에 명시한다. 예를 들어 이름과 나이만 필요한 경우
  쿼리 파라미터에 ```/users/1234?fields=name,age```와 같은 형태를 사용하여 서버가 응답해야 할 정보가 무엇인지 밝힌다.
- 클라이언트가 원하는 출력 포맷을 지정하지 않을 수도 있기 때문에 기본 포맷을 정한다.
- 속성은 카멜 또는 스네이크 표기법(언더바 표기법)으로 명명한다.
- 리소스의 갯수를 세는 표준 API를 별도로 지원하는 것이 좋다.
- 깔끔하게 출력할수 있는 옵션을 제공하는 것이 좋다.
  예를 들어 ```/users/1234?pretty_print```와 같은 형식을 사용하여 정돈된 형태의 리소스 출력을 지원한다.
