## 캐싱(caching)
- 강한(strong) 캐싱
  캐시된 리소스가 언제까지 유효한지, 언제까지 브라우저가 GET요청을 하지않아도 되는 것인지 지정함
  - Expires, max-age
    Expires와 Cache-Control헤더는 브라우저가 새 버전의 리소스 유무를 확인하지 않고 캐시된 리소스를
    가져다 써도 되는 시간을 가리킨다. 일단 이 두 헤더가 세팅되면, 만료 일자가 도래하거나 최대 수명이 경과하기
    전까지는 리소스를 갱신하지 않는다.
    Expires헤더는 리소스의 만료 일자를 의미하고, max-age속성은 리소스가 다운로드된 이후 얼마 동안 유효한지를 의미한다.
  - Cache-Control
    캐시된 리소스의 최대 수명을 의미 하며 추가적으로 다음과 같은 지시자(directive)로 캐싱 방식을 지정할 수 있다.
    - private : 객체를 캐시하는 건 브라우저만 가능하다. 프록시(proxy)나 콘텐츠 배포 네트워크는 캐시 할수 없음
    - public : 브라우저, 프록시, 콘텐츠 배포 네트워크 모두 객체를 캐시할수 있음
    - no-cache : 객체를 아예 캐시 하지 않음
    - no-store : 메모리에서는 객체를 캐시하지만 디스크에는 저장하지 않음
    - max-age : 리소스가 얼마 동안 유효한지 가리킴
    - Cache-Control HTTP/1.1 사용 예(아래의 예시는 86,400초 즉 24시간 동안 객체를 브라우저에만 캐시한다는 의미를 가짐)
      ```
        HTTP/1.1 200 OK Content-Type: application/json
        Cache-Control: private, max-age=86400
        Last-Modified: Thur, 01 Apr 2014 11:30 PST
      ```
- 약한(weak) 캐싱
  브라우저가 조건부 GET요청을 날려 캐시로 부터 아이템을 가져와야 할지 판단하기 위한 정보
  - Last-Modified, ETag
    Last-Modified는 리소스의 최종 수정 일자를 의미하고, ETag에는 리소스를 식별할 수 있는 어떤 값(예를 들어, 해시)가르킨다.
    이 두 헤더 정보를 통해 브라우저는 조건부 GET요청을 전송하여 캐시된 리소스를 효율적으로 업데이트 할 수 있다.
    조건부 GET요청은 서버 리소스가 변경되었을 경우에만 응답 전체를 받아오는데 결괒거으로 일반 GET요청 때보다 응답 속도가 빨라진다.

## 비동기 리소스에 관한 베스트 프랙티스

- 202 Accepted 메시지 전송
  비동기 요청/응답에서 유효한 리소스가 아주 오래 걸리지 않고 준비될수 있다면 API는 202 Accepted응답을 리턴해야 한다.
  요청이 접수되어 지금 처리 중이고 리소스가 곧 준비될 거라고 알리는 것이다. 또 202 Accepted 메시지 내부에 Location 헤더를
  통해 클라이언트가 생성될 리소를 어디에서 찾아야 할지 알려준다. 리소스를 바로 리턴할 수 없는 상황에서 절대 201 Created를 응답해선 안된다.

- 큐에 대기 중인 객체의 만료 시각 설정
  일정 시간이 지난 후 큐에 쌓이 객체는 마료되어야 한다. 주기적으로 제거하지 않으면 시간일 지날수록 엄청나게 많은 객체가 큐에 적제된다.

- 메시지 큐를 이용한 비동기 처리
  비동기 작업 전용 메시지 큐를 이용하여 수진자가 받아보기 전까지 메시지를 큐에서 대기시키는 방안을 생각해 볼수 있다.
  고급 메시지 대기 프로토콜(AMQP, Advanced Messaging Queuing Protocol)은 믿을 수 있고 안전한 벙법으로 메시지 구독,
  출판, 큐잉, 라우팅하는 표준을 제공한다.
  비동기 리소스 메소드를 호출하면, 일단 메시지 큐로 메시지를 보낸뒤, 다른 메시지나 이벤트 기반 작업을 비동기적으로 처리한다.
