## 메소드
- __조합 메서드(composed method)__: 다른 메소드에 대한 호출로 메소드를 작성
  - 추상화 수준이 비슷한 메소드 호출로 하나의 메소드를 구성하라.
  ```java
  void compute(){
    input();
    floags |= 0x0080; // 메소드의 자연스러운 흐름을 깨트린는 비트 연산이 중간에 있음
    output();
  }
  ```
- __의도 제시형 이름__: 메소드가 의도하는 바를 나타내는 이름
  ```java
  // 구현 전략은 메소드 이름에 가장 자주 들어가는 부가 정보다.
  Customer.linearCustomerSearch(String id);

  // 하지만, 메소드에 대한 정보를 전달한다는 측면에서 다음은 코드가 훨씬 간결하다.
  // 프로그래머가 갖고 있는 정보를 당장 전달하는 것이 능사가 아니다.
  // 때로는 정보 전달을 자제하는 것이 나은 경우도 있다.
  // 구현 전략이 사용자에게 중ㅇ요한 문제가 아니라면 이름에서 빼자.
  Customer.find(String id);
  ```
- __메소드 가시성__: 메소드는 가급적 내부 구현 전용으써 의미를 갖도록 한다.(private 접근 권한을 사용한다.)
  - 공용, 패키지, 보호, 전용의 메소드 가시성을 통해 프로그래머의 의도를 전달한다.
    - __공용__: 패키지 외부에서도 이 메소드가 유용한 것으로 사용된다는 의미를 내포함
    또한, 공용 메소드 가시성을 사욯아는 것은 프로그래머가 코드 관리를 책임지겠다는 뜻이기도 하다.
    ```java
    // 아래와 같이 공용으로 선언된 경우,
    // 구현을 담당한 프로그래머가 메소드의 수정에 대한 책임과
    // 수정을 통해 변경된 내용에 대한 공유의 책임을 가지고 있다는 의미가 있다.
    public Object next();
    ```
    - __패키지__: 패키지 가시성은 해당 메소드가 같은 패키지의 다른 객체에는 유용하지만
    패키지 외부의 객체에는 공개하지 않겠음을 의미한다.
    - __보호__: 하위 클래스를 사용해서 코드를 재사용하려 할때 유용함
    - __전용__: 외부 객체와 상관 없이 내부의 모든 메소드 호출을 제어할 수 있다는 점에서
    전용 메소드는 최고의 유연성을 확보해 준다.
  - 먼저 가장 제한적인 가시성을 선택한 후(전용 > 보호 > 패키지 > 공용) 필요에 따라 조금씩 가시성을 높이자.
- __메소드 객체__: 복잡한 메서드는 새로운 객체로 바꾼다.
  - 메서드 객체를 생성하는 순서는 다음과 같다.
    1. 메서드 이름을 따서 클래스 이름을 정한다.
    (예를 들어, ```complexCalculation()```은 ```ComplexCalculation```가 된다.)
    2. 메소드에서 사용하는 각 파리미터, 지역 변수, 필드에 대해 새로운 객체상의 필드를 생성한다.
    3. 본래 메소드의 파라미터와 메소드에서 사용하는 필드를 파리멑로 취하는 생성자를 만든다.
    4. 본래 메소드를 새로운 클래스의 ```calculate()```라는 메소드로 복사한다.
    기존 메소드에서 파라미터, 지역 변수, 필드로 사용된 값들은 이제 모두 새로운 객체의 필드가 된다.
    5. 기존 메소드의 본문을 새로운 객체의 인스턴스를 생성한 후 ```calculate()```라는 메소드로 바꾼다.
    예를 들어,
    ```java
      ComplexCalculation complexCalculation(){
        return new ComplexCalculation().calculate();
      }
    ```
    6. 본래 메소드에서 필드를 설정하는 부분이 있다면, 다음과 같이 ```calculate()```가 반환한 후에 설정한다.
    ```java
      ComplexCalculation complexCalculation(){
        ComplexCalculator calculator = new ComplexCalculator();
        calculator.calculate();
        this.mean = calculator.mean;
        this.variance = calculator.variance;
      }
    ```
  - 제일 중요한 사항은 리팩토링된 코드가 기존 코드와 똑같이 동작하는지 확인한다.
- __오버라이드 메소드__: 특화를 나타내기 위해 오버라이드를 사용한다.
  - 오버라이드를 사용한다고 상위 클래스와 하위 클래스의 메소드 중 하나를 선택해야만 하는 것은 아니다.
    ```supper.method()```등과 같이 상위 클래스의 메소드를 사용할 수 있다.
  - 하지만, 이러한 상위 클래스 메소드는 하위 클래스 중 __같은 이름의 메소드__에서만 호출하는 것이 좋다.
  하위 클래스와 상위 클래스의 여러 메소드를 자유롭게 혼합해서 사용한다면, 클래스의 흐름을 이해하기 어렵고
  오류를 포함할 가능성이 높아진다.
- __오버로드 메소드__: 같은 연산에 대해 다른 인터페이스를 제공한다.
  - 이와 같은 메소드를 선언하면, "이 메소드를 사용할 수 있는 다양한 포맷이 존재한다."는 의미이다.
  - 오버르도 규칙을 너무 복잡하게 만들지 말자. 오버로드가 너무 복잡해지면 독자는 어떤 인자를
  사용했을 때 어떤 메소드가 호출될지 알기 위해 오버로드 규칙에 대해 알아야 한다.
  - 제일 중요한 사항은 메소드 오버로드는 __파라미터 타입만 다를뿐 같은 연산을 수행해야 한다는 것이다.__
  의도가 다르다면 새로운 이름을 갖는 메소드를 사용하는 것이 좋다. __별도의 연산에 대해서는 각각 다른 이름을 사용하자.__
- __메소드 반환 타입__: 반환 타입에는 가급적 가장 일반적인 타입을 사용
  - 하지만, 경우 따라서 가급적 메소드의 적용 범위를 넓히기 위해서 의도를 드러낼 수 있는 가장 추상적인 타입을 사용하자.
  이렇게 하면 이후 구체적인 반환 클래스의 타입을 유연하게 변경할 수 있다.
  - 반환 타입을 일반화하면 세부 구현을 숨길수 있다. 예를 들어, 반환 타입을 ```List```대신 ```Collection```을 반환하면 사용자는 원소의 순서가 정해져 있는지 여부를 알 수 없다.
- __메소드 주석__: 코드 자체에서 쉽게 얻을 수 없는 정보는 주석을 통해 나타낸다.
(예를 들어, 하나의 메소드가 다른 메소드보다 먼저 수행되어야 하는 경우 등 )
- __도우미 메소드__: 주요 연산을 좀더 명확하게 표현하기 위해서 작은 전용 메소드를 사용한다.
- __디버그 출력 메소드__: ```toString()```를 사용해서 유용한 디버그 관련 정보를 출력한다.
- __변환__: 객체 형변환은 명확하게 표현한다.
  - "변환"의 구현하기 위해서는 다양한 방향으로 생각해야 한다.
    - 어떤 경우 기존 객체의 정보를 복사해서 새로운 타입의 실제 객체를 생성해야 된다.
    - 때로는 기존 객체에서 정보를 복사하지 않고 대상 객체에 대한 인터페이스를 구현할 수 도 있다.
    - 또 다른 방법으로는 실제 변환을 하지 않고 두 객체간의 공통 인터페이스를 찾아서 인터페이스를 통해
    코드를 작성하는 경우도 있다.
- __변환 메소드__: 단순하고 제한적인 변환에 대해서는 원본 객체에서 변환된 객체를 반환하는 메소드를 제공한다.
```java
  class Polar {
    // Polar 객체를 Cartesian객체로 변환하는 메소드
    Cartesian asCartesian(){
      ...
    }
  }
```
  - 변환 메소드는 읽기 쉽다는 장점 때문에 널리 사용되지만 몇가지 단점이 존재한다.
    - 하나의 변환 메소드를 만들기 위해서 원본 객체의 프로토콜을 변경해야 한다.
    - 원본 객체와 대상 객체 사이에 의존성을 생성한다.
    - 변환 객체는 필요한 변환의 수가 제한되지 않는 경우 다루기 어려워진다.(변환되어지는 범위가 명확해야 한다.)
- __변환 생성자__: 대부분의 변환에 대해서는 원본 객체를 인자로 취하는 변환될 객체의 생성자를 제공한다.
- __생성__: 객체 생성을 명확히 표현한다.
- __완결 생성자__: 완결된 형태를 갖는 객체를 반환하는 생성자를 작성한다.
- __공장 메소드__: 좀더 복잡한 객체를 새엏라 때, 생성자 대신 정적 메소드를 사용한다.
- __내부 공장__: 좀더 많은 설명이 필요하거나 이후 개선이 필요한 객체 생성의 경우 도우미 메소드로 캡슐화 한다.
- __켈렉션 접근자 메소드__: 컬렉션에 제한적인 접근만을 허용하는 메소드를 제공한다.
- __불린 설정 메소드__: 커뮤니케이션에 도움이 된다면, 불린 값을 설정하는 두개의 메소드(상태별로 하나씩)를 제공한다.
- __쿼리 메소드__: ```isXXXX()```라는 이름으로 된 메소드를 사용해서 불린 값을 반환한다.
- __동등성 메소드__: ```equals()```와 ```hashCode()```를 함께 정의한다.
- __취득 메소드__: 때로 필드 값을 반환하는 메소드를 사용해서 필드에 대한 접근을 제공한다.
- __설정 메소드__: 드물게, 메소드를 사용해서 필드 값을 설정한다.
- __안전한 복사__: 접근자 메소드를 통해 전달허가나 전달되는 인스턴스를 복사해서 앨리어스(alias)문제를 회피한다.
