## 병렬 스트림 효과적으로 사용하기
참고 : Java8 in Action (7장. 병렬 데이터 치리와 성능 237.p)

__어떤 특정 양을 기준으로 병렬 스트림 사용을 결정하지 말자.__ 정해진 기기에서 정해진 연산을 수행할 때는
이와 같은 기준을 사용 할수 있지만, 기기가 달라지면 이와 같은 기준은 아무 의미가 없어 진다.

* __확신이 서지 않는다면 직접 측정하라.__ 병렬 스트림과 순차 스트림은 변경하기 쉽기 때문에, 확신이 서지 않는다면
  적절히 테스트할 데이터를 만들어서 측정해 보자.
* __박싱을 주의하자.__ Java8은 박싱 동작을 피할수 있도록 기본형 특화 스트림(IntStream, LongStream, DoubleStream등)을 제공한다.
  따라서, 가급적이면 기본형 스트림을 사용하자.
* __순차 스트림보다 병렬 스트림이 성능이 떨어지는 연산이 있다.__ 특히 ```limit```나 ```findFirst```처럼 요소의 순서에
  의존하는 연산을 병렬 스트림에서 수행하려면 비싼 비용을 치러야 한다. 예를 들어, ```findAny```는 요소의 순서와 상관 없이
  연산하므로 ```findFirst```보다 성능이 좋다.
  스트림에 N개 요소가 순서가 상관없다면 비정렬된 스트림에 limit를 호출하는 것이 더 효율적이다.
* __스트림에서 수행하는 전체 파이프라인 연산 비용을 고려하라.__ 처리해야 할 요소가 ```N```이고 
  하나의 요소를 처리하는 데 드는 비용을 ```Q```라 하면, 전체 스트림 파이프라인 처리 비용은 ```N * Q```로 예상할수 있다.
  ```Q```가 높아진다는 것은 별열 스트림으로 성능을 개선할 수 있는 가능성이 있음을 의미한다.
* __소량의 데이터에서는 병렬 스트림이 도움이 되지 않는다.__ 소량의 데이터를 처리하는 상황에서는 병렬화 과정에서 생기는
  부가 비용을 상쇄할 수 있을 만큼의 이득을 얻지 못하기 때문이다.
* __스트림을 구성하는 자료구조가 적절한지 확인하라.__ 예를 들어, ```ArrayList```를 ```LinkedList```보다 효율적으로 분할할 수 있다.
  ```LinkedList```를 분할하려면 모든 요소를 탐색해야 하지만 ```ArrayList```는 요소를 탐색하지 않고도 리스트를 분할 할수 있다.
  그리고, ```range``` 팩토리 메서드로 만든 기본형 스트림도 쉽게 분해할 수 있다. 또한, 커스텀 ```Spliterator```를 구현해서 분해 과정을
  완벽하게 제어할 수 있다.
* __ 최종 연산의 병합 과정(예를 들어, Collector의 combiner 메서드) 비용을 살펴 보라. 병합 과정의 비용이 비싸다면
  병렬 스트림으로 얻은 성능의 이익이 서브스트림의 부분결과를 합치는 과정에서 상쇄될 수 있다.
  
#### 스트림 소스와 분해성
| 소스 | 분해성 |
| --- | --- |
| ArrayList | 훌륭함 |
| LinkedList | 나쁨 |
| IntStream.range | 훌륭함 |
| Stream.iterate | 나쁨 |
| HashSet | 좋음 |
| TreeSet | 좋음 | 

